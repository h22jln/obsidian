
### 체크 예외
어플리케이션 로직에서 사용하는 실질적인 예외의 최상위 클래스가 `Exception`인데,
이를 상속받은 예외 클래스들을 체크 예외라고 한다
컴파일러가 체크하는 예외이다
*단, 언체크예외(런타임 예외) 제외*

체크 예외는 받아서 던지거나, 처리하거나 하는 로직을 반드시 명시적으로 선언해야 한다
*처리할 수 없을 때, throws를 반드시 선언해야 함*

체크 예외는 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 잡아준다
그러나 신경쓰고 싶지 않은 예외까지 필수로 처리해야 하므로 번거롭다

#### 체크 예외의 문제점
1. 복구 불가능한 예외
	대부분의 예외는 복구가 불가능하다
	서비스나 컨트롤러에서는 처리가 불가능 하므로 일관성있게 공통으로 필터, 인터셉터같은 곳에서 처리하는것이 좋다

2. 의존 관계에 대한 문제
	체크 예외는 처리할 수 없어도 무조건 throws를 통해 예외를 던지는 것을 선언해야 한다
	계속 밖으로 던지게 되면 서비스, 컨트롤러가 해당 예외 클래스에 의존하게 된다


### 언체크 예외(런타임 예외)
`Exception`을 상속받은 예외 클래스 중 `RuntimeException`을 상속받은 클래스들은 언체크예외 / 런타임 예외라고 한다
컴파일러가 체크하지 않는 예외이다

언체크 예외는 받아서 던지거나, 처리하거나 하는 로직을 꼭 선언하지 않아도 된다
**잡거나, 던지지 않으면 자동으로 밖으로 던진다**

*처리할 수 없을 때, throws를 선언하지 않아도 됨
선언한다고 해서 에러가 발생하는 것도 아니다
오히려 선언해두면 IDE를 통해 인지할 수 있는 장점도 있다*

언체크 예외는 신경쓰고 싶지 않은 예외를 처리하지 않아도 된다
그러나 컴파일러가 체크하지 않으므로 실수로 누락할 가능성이 있다

#### 체크 예외와의 비교
1. 복구 불가능한 예외
	시스템에서 발생한 예외는 대부분 복구 불가능 예외이므로 런타임 예외를 사용하면 서비스나 컨트롤러가 신경쓰지 않아도 된다

2. 의존 관계에 대한 문제
	런타임 예외는 해당 객체가 처리할 수 없는 예외는 무시하면 되므로 딱히 의존하지 않는다

```
static class Repository {
    public void call() {
		
        try {
            runSQL();
			
        } catch (SQLException e) {
            throw new RuntimeSQLException(e);
} }

    private void runSQL() throws SQLException {
        throw new SQLException("ex");

} }
```
이와 같이 체크 예외를 잡아서 런타임 예외로 변환할 수 있다
-> ==예외 전환시 기존 예외를 꼭 넣어주자==

런타임 예외는 놓칠 수 있기 때문에 문서화가 중요하다
또는 코드에 throws를 남겨서 중요한 예외를 인지할 수 있게 하자