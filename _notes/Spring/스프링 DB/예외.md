
### 체크 예외
어플리케이션 로직에서 사용하는 실질적인 예외의 최상위 클래스가 `Exception`인데,
이를 상속받은 예외 클래스들을 체크 예외라고 한다
컴파일러가 체크하는 예외이다
*단, 언체크예외(런타임 예외) 제외*

체크 예외는 받아서 던지거나, 처리하거나 하는 로직을 반드시 명시적으로 선언해야 한다
*처리할 수 없을 때, throws를 반드시 선언해야 함*

체크 예외는 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 잡아준다
그러나 신경쓰고 싶지 않은 예외까지 필수로 처리해야 하므로 번거롭다

#### 체크 예외의 문제점
1. 복구 불가능한 예외
	대부분의 예외는 복구가 불가능하다
	서비스나 컨트롤러에서는 처리가 불가능 하므로 일관성있게 공통으로 필터, 인터셉터같은 곳에서 처리하는것이 좋다

2. 의존 관계에 대한 문제
	체크 예외는 처리할 수 없어도 무조건 throws를 통해 예외를 던지는 것을 선언해야 한다
	계속 밖으로 던지게 되면 서비스, 컨트롤러가 해당 예외 클래스에 의존하게 된다

#### 인터페이스
체크 예외를 던지는 메소드를 인터페이스로 추상화 하려면, 인터페이스에도 해당 체크 예외가 선언되어 있어야 한다 => ==예외 누수==
```
Member save(Member member) throws SQLException;
```

인터페이스를 사용하고자 하는 경우에는, 클래스 내부에서 체크 예외를 잡아서 런타임 예외로 바꿔주는 것이 좋다


### 언체크 예외(런타임 예외)
`Exception`을 상속받은 예외 클래스 중 `RuntimeException`을 상속받은 클래스들은 언체크예외 / 런타임 예외라고 한다
컴파일러가 체크하지 않는 예외이다

언체크 예외는 받아서 던지거나, 처리하거나 하는 로직을 꼭 선언하지 않아도 된다
**잡거나, 던지지 않으면 자동으로 밖으로 던진다**

*처리할 수 없을 때, throws를 선언하지 않아도 됨
선언한다고 해서 에러가 발생하는 것도 아니다
오히려 선언해두면 IDE를 통해 인지할 수 있는 장점도 있다*

언체크 예외는 신경쓰고 싶지 않은 예외를 처리하지 않아도 된다
그러나 컴파일러가 체크하지 않으므로 실수로 누락할 가능성이 있다

#### 체크 예외와의 비교
1. 복구 불가능한 예외
	시스템에서 발생한 예외는 대부분 복구 불가능 예외이므로 런타임 예외를 사용하면 서비스나 컨트롤러가 신경쓰지 않아도 된다

2. 의존 관계에 대한 문제
	런타임 예외는 해당 객체가 처리할 수 없는 예외는 무시하면 되므로 딱히 의존하지 않는다

```
static class Repository {
    public void call() {
		
        try {
            runSQL();
			
        } catch (SQLException e) {
            throw new RuntimeSQLException(e);
} }

    private void runSQL() throws SQLException {
        throw new SQLException("ex");

} }
```
이와 같이 체크 예외를 잡아서 런타임 예외로 변환할 수 있다
-> ==예외 전환시 기존 예외를 꼭 넣어주자==

런타임 예외는 놓칠 수 있기 때문에 문서화가 중요하다
또는 코드에 throws를 남겨서 중요한 예외를 인지할 수 있게 하자

***

### 스프링에서의 예외

#### 스프링 예외 추상화
스프링은 데이터 접근 기능에 대해 특정 기술에 종속적이지 않은 일관된 예외 계층을 제공한다

DataAccessException이 최고 상위 예외이며, 런타임 예외이다
이 예외는 크게 2가지로 분류할 수 있는데
- Transient
	일시적인 예외로 다시 시도했을 때 성공할 가능성이 있다
	*ex)쿼리 타임아웃, 락*

- NonTransient
	일시적이지 않은 예외로, 다시 시도해도 성공하지 않는다
	*ex) 문법오류, PK중복*


#### 스프링 예외 변환기
DB에서 발생하는 오류 코드는 각각 어떤 기술을 쓰느냐에 따라 다르기 때문에 일일이 정의할 수 없다
스프링은 오류 코드를 정의한 예외로 자동 변환해주는 변환기를 제공한다
```
SQLExceptionTranslator exTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);
DataAccessException resultEx = exTranslator.translate("select", sql, e);
```

translate(임의의 구분값, 쿼리, Exception)을 호출하면, 스프링이 알아서 쿼리와 Exception을 분석해 스프링 Exception으로 변환한다